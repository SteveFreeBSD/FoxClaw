# WS-24: Optional Live Workflow Architecture

## Context
FoxClaw has a strict constraint: **Scan runtime stays offline-by-default.** Currently, scanning requires an analyst to explicitly know if their local intelligence database is up-to-date, run `foxclaw intel sync` if it isn't, and then manually run `foxclaw scan`. 

While secure and deterministic, this workflow is tedious for users who simply want a "one-click" live assessment of a profile using the absolute latest AMO, KEV, and CVE threat intelligence.

## Objective
Implement an optional "wrapper" command (e.g., `foxclaw live`) that orchestrates an intelligence sync immediately followed by a scan.

## Core Architectural Guardrails
1. **Separation of Concerns**: The `scan` command itself must remain entirely offline. The `live` command must act purely as an orchestration layer traversing `foxclaw.intel.sync` and `foxclaw.cli.scan`.
2. **Deterministic Replayability**: Any findings generated by `foxclaw live` must be fully reproducible. The wrapper must capture the exact Snapshot ID generated by the `sync` step and explicitly pass it to (or record it alongside) the subsequent `scan` to preserve provenance.
3. **Fail-Closed on Network Outage**: If the `sync` step fails due to network outage or a blocked trusted mirror, the wrapper must fail gracefully and safely abort the scan, rather than silently falling back to stale data.
4. **Explicit Opt-In**: The `live` wrapper should clearly warn the user that it will perform network requests, perhaps requiring an explicit flag if run inside CI environments (e.g., `--accept-network`).

## Proposed Implementation Steps

### 1. The `foxclaw live` CLI Command
Add a new command to `foxclaw/cli.py` (or a dedicated `foxclaw/live.py`) using `argparse` or the existing CLI framework. It will accept arguments for both `sync` and `scan`.

### 2. Orchestration Logic
```python
def execute_live_workflow(profile_path: Path, ruleset_path: Path) -> int:
    # Step 1: Execute Sync
    snapshot_id = perform_intel_sync(...)
    if not snapshot_id:
        return EXIT_SYNC_FAILURE
        
    # Step 2: Execute Scan pinned to the new Snapshot ID
    return perform_scan(
        profile_path=profile_path,
        ruleset_path=ruleset_path,
        # Ensuring provenance is maintained
        pinned_snapshot_id=snapshot_id 
    )
```

### 3. Tests and Documentation
- Update `docs/DEVELOPMENT.md` to showcase the new command.
- Add regression coverage in `tests/test_live_orchestration.py` mocking the network layer.

## User Review
Please review this approach. If it aligns with the strict determinism and safety goals of FoxClaw, we will begin writing the orchestration code.
